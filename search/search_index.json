{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About netID \u00b6 The European netID Foundation was founded in March 2018 by Mediengruppe RTL Deutschland, ProSiebenSat.1 and United Internet. Its aim is to establish the netID single sign-on as a European alternative to US providers. With netID, users can organize their consent to the use of internet services (opt-ins) transparently and in compliance with data protection regulations. To this end, the foundation has developed an open standard that enables users from all sectors to access all internet services of partners of the European netID Foundation with the same log-in. Right from the start which focuses the initial core market Germany, 38 million accounts covering roughly about 60% of the Germany online population are ready to be used. https://netid.de/ https://enid.foundation/","title":"About"},{"location":"#about-netid","text":"The European netID Foundation was founded in March 2018 by Mediengruppe RTL Deutschland, ProSiebenSat.1 and United Internet. Its aim is to establish the netID single sign-on as a European alternative to US providers. With netID, users can organize their consent to the use of internet services (opt-ins) transparently and in compliance with data protection regulations. To this end, the foundation has developed an open standard that enables users from all sectors to access all internet services of partners of the European netID Foundation with the same log-in. Right from the start which focuses the initial core market Germany, 38 million accounts covering roughly about 60% of the Germany online population are ready to be used. https://netid.de/ https://enid.foundation/","title":"About netID"},{"location":"cmp_1/","text":"General information \u00b6 This White Paper was prepared by the European netID Foundation (\"EnID\") and by 1&1 Mail & Media GmbH (\"1&1\") - as a recognized technical service provider of \"EnID\" - to the best of their knowledge, with due diligence and taking into account the current state of knowledge and development. \"EnID\" and \"1&1\" and their legal representatives and/or vicarious agents do not guarantee that the contents of this white paper are secure, completely usable for certain purposes or otherwise free of errors. The use of this white paper is solely at your own risk. In no case \"EnID\" and \"1&1\" and their legal representatives and/or vicarious agents are liable for any damage, whether direct or indirect, resulting from the use of the white paper. netID Permission Center Services \u00b6 The following netID Permission Center Services are provided which allow a CMP to store / manage netID Permissions, TC Strings for a netID Partner: READ SERVICE (read the netID identifier (TPID) or netID permissions, TC strings ) WRITE SERVICE (Writing the netID Permissions, TC Strings ) DATA EXPORT SERVICE (exporting the netID permissions, TC strings for the partner) Currently there is only one netID permission, namely identification. netID does not support the collection and processing of TC strings with global scope. Interfaces \u00b6 The following functionalities are provided to the CMP: browser-based APIs: Reading the netID identifier of a specific user (TPID) Save and retrieve the TC string for the publisher in the netID Permission Center. server-based APIs: Save and retrieve the TC string for the publisher in the netID Permission Center. Data export (exporting the netID permissions / TC String of the partner) The distinction browser vs. server-based refers mainly to how active users are identified / from where the APIs are being called. Call information: Parameters / Header / Cookies name type function description tapp_id parameter authentication is made available by netID for each publisher when it is onboarded on and must be passed unchanged with each request. origin header authentication is passed by the browser for each XMLHttpsRequest (AJAX). The value must be a URL registered for this partner (TAPP). tpid_sec cookie user identification Only relevant for the browser-based API: is located in the netid.de domain and is automatically passed on by the browser - if available. token parameter User recognition/Access Token Only relevant for the server-based API: Can be retrieved by the partner via the SSO process, is passed to access the API/identify the user Authentication netID Partner \u00b6 Authentication of partners for the browser-based APIs is handled via the parameter tapp_id and the Origin header. Access is secured via CORS. Multiple URLs are allowed per publisher (TAPP). The publisher has to register those URLs upfront The read/write request must be made from an eligible URL. Authentication with the server-based APIs is done as follows. The user-specific read/write accesses are secured via access tokens. Generic Data Export using Basic Authentication User recognition when using APIs \u00b6 The recognition of the active netID user takes place depending on the API used by means of the tpid_sec (browser-based) or the token (server-based). tpid_sec is an ID Token (JWT) which is stored on the domain netid.de as part of the SSO session information for the provision of the netID service during login processes via the SSO/general login with the netID account provider. This ID token is not accessible for partners / the CMP. The Login token can be retrieved by a publisher during the SSO process (OpenID Connect) in the form of a claim. This enables read/write access independently of the SSO session (limited in time). If, depending on the context, the token or the tpid_sec does not exist, has expired or is invalid, a publisher cannot read/write the TC String and of course cannot access the TPID.","title":"General information"},{"location":"cmp_1/#general-information","text":"This White Paper was prepared by the European netID Foundation (\"EnID\") and by 1&1 Mail & Media GmbH (\"1&1\") - as a recognized technical service provider of \"EnID\" - to the best of their knowledge, with due diligence and taking into account the current state of knowledge and development. \"EnID\" and \"1&1\" and their legal representatives and/or vicarious agents do not guarantee that the contents of this white paper are secure, completely usable for certain purposes or otherwise free of errors. The use of this white paper is solely at your own risk. In no case \"EnID\" and \"1&1\" and their legal representatives and/or vicarious agents are liable for any damage, whether direct or indirect, resulting from the use of the white paper.","title":"General information"},{"location":"cmp_1/#netid-permission-center-services","text":"The following netID Permission Center Services are provided which allow a CMP to store / manage netID Permissions, TC Strings for a netID Partner: READ SERVICE (read the netID identifier (TPID) or netID permissions, TC strings ) WRITE SERVICE (Writing the netID Permissions, TC Strings ) DATA EXPORT SERVICE (exporting the netID permissions, TC strings for the partner) Currently there is only one netID permission, namely identification. netID does not support the collection and processing of TC strings with global scope.","title":"netID Permission Center Services"},{"location":"cmp_1/#interfaces","text":"The following functionalities are provided to the CMP: browser-based APIs: Reading the netID identifier of a specific user (TPID) Save and retrieve the TC string for the publisher in the netID Permission Center. server-based APIs: Save and retrieve the TC string for the publisher in the netID Permission Center. Data export (exporting the netID permissions / TC String of the partner) The distinction browser vs. server-based refers mainly to how active users are identified / from where the APIs are being called. Call information: Parameters / Header / Cookies name type function description tapp_id parameter authentication is made available by netID for each publisher when it is onboarded on and must be passed unchanged with each request. origin header authentication is passed by the browser for each XMLHttpsRequest (AJAX). The value must be a URL registered for this partner (TAPP). tpid_sec cookie user identification Only relevant for the browser-based API: is located in the netid.de domain and is automatically passed on by the browser - if available. token parameter User recognition/Access Token Only relevant for the server-based API: Can be retrieved by the partner via the SSO process, is passed to access the API/identify the user","title":"Interfaces"},{"location":"cmp_1/#authentication-netid-partner","text":"Authentication of partners for the browser-based APIs is handled via the parameter tapp_id and the Origin header. Access is secured via CORS. Multiple URLs are allowed per publisher (TAPP). The publisher has to register those URLs upfront The read/write request must be made from an eligible URL. Authentication with the server-based APIs is done as follows. The user-specific read/write accesses are secured via access tokens. Generic Data Export using Basic Authentication","title":"Authentication netID Partner"},{"location":"cmp_1/#user-recognition-when-using-apis","text":"The recognition of the active netID user takes place depending on the API used by means of the tpid_sec (browser-based) or the token (server-based). tpid_sec is an ID Token (JWT) which is stored on the domain netid.de as part of the SSO session information for the provision of the netID service during login processes via the SSO/general login with the netID account provider. This ID token is not accessible for partners / the CMP. The Login token can be retrieved by a publisher during the SSO process (OpenID Connect) in the form of a claim. This enables read/write access independently of the SSO session (limited in time). If, depending on the context, the token or the tpid_sec does not exist, has expired or is invalid, a publisher cannot read/write the TC String and of course cannot access the TPID.","title":"User recognition when using APIs"},{"location":"cmp_2/","text":"Browser-based API (web browser integration) \u00b6 Description of the browser-based integration of the netID Permission Center by the CMP (integration directly in the user\\'s browser (JavaScript)). Exemplary Procedure for obtaining Consents \u00b6 JS checks for the presence of a cookie with the TC string in the Publisher domain. If there is no TC string present \u2192 JS tries to retrieve the TC string from the netID READ SERVICE If a TC String exists and permissions suffice \u2192 abort and continue processing. Otherwise display overlay for the purpose of obtaining permissions from the user. User makes his choice (TCF /identification with netID) via the CMP Interface JS writes the TC String via the netID WRITE SERVICE, as well as (if given) the consent for identification via netID. JS also writes the TC string as a local cookie in the publisher domain. Reading the netID Identifier (TPID) \u00b6 If the ORIGIN is eligible, a publisher (TAPP) can retrieve the netID Identifier (TPID) via the following interface: GET https://READSERVICE.netid.de/identification/tpid?tapp_id = <TAPP_ID> Accept: application/vnd.netid.identification.tpid-read-v1+json Cookie: tpid_sec = <JWT_TOKEN> Origin: <ORIGIN> 200 OK Content-Type: application/vnd.netid.identification.tpid-read-v1+json Access-Control-Allow-Origin: <ORIGIN> Access-Control-Allow-Credentials: true { \"tpid\" : \"<TPID>|null\" \"status\" : \"OK|NO_TPID|TOKEN_ERROR|CONSENT_REQUIRED\" } JSON Properties \u00b6 Description tpid The ID of the netID user ( tpid ). Only if consent \"Identification\" is given, the tpid is present and status \"OK\". Otherwise null. status meaning pid OK Call successful x NO_TPID There was no tpid_sec cookie available. - TOKEN_ERROR Token (JWT) in the cookie has expired or is invalid. - CONSENT_REQUIRED Consent for passing on the TPID missing (\"Identification\"). - Read permission (TC string) \u00b6 GET https://READSERVICE.netid.de/permissions/iab-permissions?tapp_id = <TAPP_ID> Accept: application/vnd.netid.permissions.iab-permission-read-v1+json Cookie: tpid_sec = <JWT_TOKEN> Origin: <ORIGIN> 200 OK Content-Type: application/vnd.netid.permissions.iab-permission-read-v1+json Access-Control-Allow-Origin: <ORIGIN> Access-Control-Allow-Credentials: true { \"tpid\" : \"<TPID>|null\" , \"tc\" : \"<TC string>|null\" , \"status\" : \"OK|NO_TPID|TOKEN_ERROR|CONSENT_REQUIRED\" } JSON Properties \u00b6 Description tpid The ID of the netID user ( tpid ). Only if consent \"Identification\" is given, the tpid is present and status \"OK\". Otherwise null. tc The TC string stored for this tpid for this publisher (TCF 2.0). Only with status \"OK\". Otherwise null. status meaning tc pid OK Status successfully retrieved x x NO_TPID There was no tpid_sec cookie available. - - TOKEN_ERROR Token (JWT) in the cookie has expired or is invalid. - - CONSENT_REQUIRED Consent for passing on the TPID missing (\"Identification\"). x - Write permission (TC string) \u00b6 POST https://WRITESERVICE.netid.de/permissions/iab-permissions?tapp_id = <TAPP_ID> Content-Type: application/vnd.netid.permissions.iab-permission-write-v1+json Cookie: tpid_sec = <JWT_TOKEN> Origin: <ORIGIN> { \"identification\" : \"true|false\" , \"tc\" : \"<TC string>\" } 201 CREATED Location: https://READSERVICE.netid.de/permissions/iab-permissions?tapp_id = <TAPP_ID> Access-Control-Allow-Origin: <ORIGIN> Access-Control-Allow-Credentials: true { \"tpid\" : \"<TPID>|null\" , \"status\" : \"OK|NO_TPID|TOKEN_ERROR\" } Remarks: If permission \"identification\" has been given by the user, this must be signaled by passing \"identification: true\". For the avoidance of doubt, this of course requires the prior collection of this consent by the CMP. If only the TC string is to be updated and the permission \"Identification\" already exists, only the \"tc\" attribute can be passed. Both can also be written at the same time. In case of revocation of permission \"Identification\", would pass only \"identification: false\". JSON Properties \u00b6 request Description identification The permission \"Identification\" (ID CONSENT) is to be stored (or revoked). tc The TC String which should be stored for this tpid` for this publisher (TCF 2.0). response Description tpid The ID of the netID user ( tpid ). Only if consent \"Identification\" is given, the tpid is present and status \"OK\". Otherwise zero. status meaning OK TC String / ID CONSENT was saved. NO_TPID There was no tpid_sec cookie available. TOKEN_ERROR Token (JWT) in the cookie has expired or is invalid.","title":"Browser-based API"},{"location":"cmp_2/#browser-based-api-web-browser-integration","text":"Description of the browser-based integration of the netID Permission Center by the CMP (integration directly in the user\\'s browser (JavaScript)).","title":"Browser-based API (web browser integration)"},{"location":"cmp_2/#exemplary-procedure-for-obtaining-consents","text":"JS checks for the presence of a cookie with the TC string in the Publisher domain. If there is no TC string present \u2192 JS tries to retrieve the TC string from the netID READ SERVICE If a TC String exists and permissions suffice \u2192 abort and continue processing. Otherwise display overlay for the purpose of obtaining permissions from the user. User makes his choice (TCF /identification with netID) via the CMP Interface JS writes the TC String via the netID WRITE SERVICE, as well as (if given) the consent for identification via netID. JS also writes the TC string as a local cookie in the publisher domain.","title":"Exemplary Procedure for obtaining Consents"},{"location":"cmp_2/#reading-the-netid-identifier-tpid","text":"If the ORIGIN is eligible, a publisher (TAPP) can retrieve the netID Identifier (TPID) via the following interface: GET https://READSERVICE.netid.de/identification/tpid?tapp_id = <TAPP_ID> Accept: application/vnd.netid.identification.tpid-read-v1+json Cookie: tpid_sec = <JWT_TOKEN> Origin: <ORIGIN> 200 OK Content-Type: application/vnd.netid.identification.tpid-read-v1+json Access-Control-Allow-Origin: <ORIGIN> Access-Control-Allow-Credentials: true { \"tpid\" : \"<TPID>|null\" \"status\" : \"OK|NO_TPID|TOKEN_ERROR|CONSENT_REQUIRED\" }","title":"Reading the netID Identifier (TPID)"},{"location":"cmp_2/#json-properties","text":"Description tpid The ID of the netID user ( tpid ). Only if consent \"Identification\" is given, the tpid is present and status \"OK\". Otherwise null. status meaning pid OK Call successful x NO_TPID There was no tpid_sec cookie available. - TOKEN_ERROR Token (JWT) in the cookie has expired or is invalid. - CONSENT_REQUIRED Consent for passing on the TPID missing (\"Identification\"). -","title":"JSON Properties"},{"location":"cmp_2/#read-permission-tc-string","text":"GET https://READSERVICE.netid.de/permissions/iab-permissions?tapp_id = <TAPP_ID> Accept: application/vnd.netid.permissions.iab-permission-read-v1+json Cookie: tpid_sec = <JWT_TOKEN> Origin: <ORIGIN> 200 OK Content-Type: application/vnd.netid.permissions.iab-permission-read-v1+json Access-Control-Allow-Origin: <ORIGIN> Access-Control-Allow-Credentials: true { \"tpid\" : \"<TPID>|null\" , \"tc\" : \"<TC string>|null\" , \"status\" : \"OK|NO_TPID|TOKEN_ERROR|CONSENT_REQUIRED\" }","title":"Read permission (TC string)"},{"location":"cmp_2/#json-properties_1","text":"Description tpid The ID of the netID user ( tpid ). Only if consent \"Identification\" is given, the tpid is present and status \"OK\". Otherwise null. tc The TC string stored for this tpid for this publisher (TCF 2.0). Only with status \"OK\". Otherwise null. status meaning tc pid OK Status successfully retrieved x x NO_TPID There was no tpid_sec cookie available. - - TOKEN_ERROR Token (JWT) in the cookie has expired or is invalid. - - CONSENT_REQUIRED Consent for passing on the TPID missing (\"Identification\"). x -","title":"JSON Properties"},{"location":"cmp_2/#write-permission-tc-string","text":"POST https://WRITESERVICE.netid.de/permissions/iab-permissions?tapp_id = <TAPP_ID> Content-Type: application/vnd.netid.permissions.iab-permission-write-v1+json Cookie: tpid_sec = <JWT_TOKEN> Origin: <ORIGIN> { \"identification\" : \"true|false\" , \"tc\" : \"<TC string>\" } 201 CREATED Location: https://READSERVICE.netid.de/permissions/iab-permissions?tapp_id = <TAPP_ID> Access-Control-Allow-Origin: <ORIGIN> Access-Control-Allow-Credentials: true { \"tpid\" : \"<TPID>|null\" , \"status\" : \"OK|NO_TPID|TOKEN_ERROR\" } Remarks: If permission \"identification\" has been given by the user, this must be signaled by passing \"identification: true\". For the avoidance of doubt, this of course requires the prior collection of this consent by the CMP. If only the TC string is to be updated and the permission \"Identification\" already exists, only the \"tc\" attribute can be passed. Both can also be written at the same time. In case of revocation of permission \"Identification\", would pass only \"identification: false\".","title":"Write permission (TC string)"},{"location":"cmp_2/#json-properties_2","text":"request Description identification The permission \"Identification\" (ID CONSENT) is to be stored (or revoked). tc The TC String which should be stored for this tpid` for this publisher (TCF 2.0). response Description tpid The ID of the netID user ( tpid ). Only if consent \"Identification\" is given, the tpid is present and status \"OK\". Otherwise zero. status meaning OK TC String / ID CONSENT was saved. NO_TPID There was no tpid_sec cookie available. TOKEN_ERROR Token (JWT) in the cookie has expired or is invalid.","title":"JSON Properties"},{"location":"cmp_3/","text":"Server-based API (backend integration) \u00b6 Description of the backend integration of the netID Permission Center by the CMP (integration from the server side / backend of the CMP if available). In the case of first use and netID registration via the SSO flow, the publisher (TAPP) receives the authentication token ( token ) after the successful login, with which the user can be authenticated at the netID Permission Center. The CMP can use this authentication token to read and write the netID permissions / TC string of the user. Remarks: The server-based requests are secured by the authentication token. Calls of this type are blocked from the web (no Origin header is allowed!) Reading the netID Identifier (TPID) \u00b6 A CMP can retrieve the netID Identifier (TPID) via the following interface: GET https://READSERVICE.netid.de/identification/tpid?token = <TOKEN> Accept: application/vnd.netid.identification.tpid-read-v1+json 200 OK Content-Type: application/vnd.netid.identification.tpid-read-v1+json { \"tpid\" : \"<TPID>|null\" \"status\" : \"OK|NO_TOKEN|TOKEN_ERROR|CONSENT_REQUIRED\" } JSON Properties \u00b6 Description tpid The ID of the netID user ( tpid ). Only if consent \"Identification\" is given, the tpid is present and status \"OK\". Otherwise null. status meaning tc oder pid??? @andrea OK A TC string was stored for this TPID. x NO_TOKEN No authentication token was transferred. - TOKEN_ERROR Authentication token (JWT) has expired or is invalid. - CONSENT_REQUIRED Consent for passing on the TPID missing (\"Identification\"). x Read permission (Identification, TC string) \u00b6 GET https://READSERVICE.netid.de/permissions/iab-permissions?token = <TOKEN> Accept: application/vnd.netid.permissions.iab-permission-read-v1+json 200 OK Content-Type: application/vnd.netid.permissions.iab-permission-read-v1+json { \"tpid\" : \"<TPID>|null\" , \"tc\" : \"<TC string>|null\" , \"status\" : \"OK|NO_TOKEN|TOKEN_ERROR|CONSENT_REQUIRED\" } JSON Properties \u00b6 Description tpid The ID of the netID user ( tpid ). Only if consent \"Identification\" is given, the tpid is present and status \"OK\". Otherwise null. tc The TC string stored for this tpid for this publisher (TCF 2.0). Only with status \"OK\". Otherwise null. status significance tc pid OK TC String was stored for this tpid . x x NO_TPID No authentication token was transferred. - - TOKEN_ERROR Authentication token (JWT) has expired or is invalid. - - CONSENT_REQUIRED Consent for passing on the tpid missing (\"Identification\"). x - Writing the permission (identification, TC string) \u00b6 POST https://WRITESERVICE.netid.de/permissions/iab-permissions?token = <TOKEN> Content-Type: application/vnd.netid.permissions.iab-permission-write-v1+json { \"identification\" : \"true|false\" , \"tc\" : \"<TC string>\" } 201 CREATED Location: https://READSERVICE.netid.de/permissions/iab-permissions?token = <TOKEN> { \"tpid\" : \"<TPID>|null\" , \"status\" : \"OK|NO_TOKEN|TOKEN_ERROR\" } Remarks: If permission \"identification\" has been given by the user, this must be signaled by passing \"identification: true\". For the avoidance of doubt, this of course requires the prior collection of this consent by the CMP. If only the TC string is to be updated and the permission \"Identification\" already exists, only the \"tc\" attribute can be passed. Both can also be written at the same time. In case of revocation of permission \"Identification\", would pass only \"identification: false\". JSON Properties \u00b6 request Description identification The permission \"Identification\" (ID CONSENT) is to be stored (or not). tc The TC String which should be stored for this TPID for this publisher (TCF 2.0). response Description tpid The ID of the netID user ( tpid ). Only if consent \"Identification\" is given, the tpid is present and status \"OK\". Otherwise null. status significance OK TC String / ID CONSENT was saved. NO_TOKEN No authentication token was transferred. TOKEN_ERROR Authentication token (JWT) has expired or is invalid.","title":"Server-based API"},{"location":"cmp_3/#server-based-api-backend-integration","text":"Description of the backend integration of the netID Permission Center by the CMP (integration from the server side / backend of the CMP if available). In the case of first use and netID registration via the SSO flow, the publisher (TAPP) receives the authentication token ( token ) after the successful login, with which the user can be authenticated at the netID Permission Center. The CMP can use this authentication token to read and write the netID permissions / TC string of the user. Remarks: The server-based requests are secured by the authentication token. Calls of this type are blocked from the web (no Origin header is allowed!)","title":"Server-based API (backend integration)"},{"location":"cmp_3/#reading-the-netid-identifier-tpid","text":"A CMP can retrieve the netID Identifier (TPID) via the following interface: GET https://READSERVICE.netid.de/identification/tpid?token = <TOKEN> Accept: application/vnd.netid.identification.tpid-read-v1+json 200 OK Content-Type: application/vnd.netid.identification.tpid-read-v1+json { \"tpid\" : \"<TPID>|null\" \"status\" : \"OK|NO_TOKEN|TOKEN_ERROR|CONSENT_REQUIRED\" }","title":"Reading the netID Identifier (TPID)"},{"location":"cmp_3/#json-properties","text":"Description tpid The ID of the netID user ( tpid ). Only if consent \"Identification\" is given, the tpid is present and status \"OK\". Otherwise null. status meaning tc oder pid??? @andrea OK A TC string was stored for this TPID. x NO_TOKEN No authentication token was transferred. - TOKEN_ERROR Authentication token (JWT) has expired or is invalid. - CONSENT_REQUIRED Consent for passing on the TPID missing (\"Identification\"). x","title":"JSON Properties"},{"location":"cmp_3/#read-permission-identification-tc-string","text":"GET https://READSERVICE.netid.de/permissions/iab-permissions?token = <TOKEN> Accept: application/vnd.netid.permissions.iab-permission-read-v1+json 200 OK Content-Type: application/vnd.netid.permissions.iab-permission-read-v1+json { \"tpid\" : \"<TPID>|null\" , \"tc\" : \"<TC string>|null\" , \"status\" : \"OK|NO_TOKEN|TOKEN_ERROR|CONSENT_REQUIRED\" }","title":"Read permission (Identification, TC string)"},{"location":"cmp_3/#json-properties_1","text":"Description tpid The ID of the netID user ( tpid ). Only if consent \"Identification\" is given, the tpid is present and status \"OK\". Otherwise null. tc The TC string stored for this tpid for this publisher (TCF 2.0). Only with status \"OK\". Otherwise null. status significance tc pid OK TC String was stored for this tpid . x x NO_TPID No authentication token was transferred. - - TOKEN_ERROR Authentication token (JWT) has expired or is invalid. - - CONSENT_REQUIRED Consent for passing on the tpid missing (\"Identification\"). x -","title":"JSON Properties"},{"location":"cmp_3/#writing-the-permission-identification-tc-string","text":"POST https://WRITESERVICE.netid.de/permissions/iab-permissions?token = <TOKEN> Content-Type: application/vnd.netid.permissions.iab-permission-write-v1+json { \"identification\" : \"true|false\" , \"tc\" : \"<TC string>\" } 201 CREATED Location: https://READSERVICE.netid.de/permissions/iab-permissions?token = <TOKEN> { \"tpid\" : \"<TPID>|null\" , \"status\" : \"OK|NO_TOKEN|TOKEN_ERROR\" } Remarks: If permission \"identification\" has been given by the user, this must be signaled by passing \"identification: true\". For the avoidance of doubt, this of course requires the prior collection of this consent by the CMP. If only the TC string is to be updated and the permission \"Identification\" already exists, only the \"tc\" attribute can be passed. Both can also be written at the same time. In case of revocation of permission \"Identification\", would pass only \"identification: false\".","title":"Writing the permission (identification, TC string)"},{"location":"cmp_3/#json-properties_2","text":"request Description identification The permission \"Identification\" (ID CONSENT) is to be stored (or not). tc The TC String which should be stored for this TPID for this publisher (TCF 2.0). response Description tpid The ID of the netID user ( tpid ). Only if consent \"Identification\" is given, the tpid is present and status \"OK\". Otherwise null. status significance OK TC String / ID CONSENT was saved. NO_TOKEN No authentication token was transferred. TOKEN_ERROR Authentication token (JWT) has expired or is invalid.","title":"JSON Properties"},{"location":"cmp_4/","text":"Data export for partners \u00b6 Via this API partners get the ability to query netID permissions and TC strings of users (export) unrelated to a specific context, via the specification of changed_since deltas can also be queried. There is an HTTP service with a REST API for this service. GET https://DATA-EXPORT-SERVICE/permissions/iab-permissions? tapp_id = <TAPP_ID> & changed_since = <DATE> Accept: application/vnd.netid.permissions.iab-permission-export.list-v1+json Authorization: Basic <b64 ( USERNAME:PASSWORD ) > 200 OK Content-Type: application/vnd.netid.permissions.iab-permission-export.list-v1+json { [ { \"tpid\" : \"<tpid>\" , \"type\" : \"IDCONSENT\" , \"status\" : \"VALID\" , \"changed_at\" : \"<timestamp>\" } , { \"tpid\" : \"<tpid>\" , \"tc\" : \"<tc-string>\" , \"changed_at\" : \"<timestamp>\" } ] }","title":"Data export for partners"},{"location":"cmp_4/#data-export-for-partners","text":"Via this API partners get the ability to query netID permissions and TC strings of users (export) unrelated to a specific context, via the specification of changed_since deltas can also be queried. There is an HTTP service with a REST API for this service. GET https://DATA-EXPORT-SERVICE/permissions/iab-permissions? tapp_id = <TAPP_ID> & changed_since = <DATE> Accept: application/vnd.netid.permissions.iab-permission-export.list-v1+json Authorization: Basic <b64 ( USERNAME:PASSWORD ) > 200 OK Content-Type: application/vnd.netid.permissions.iab-permission-export.list-v1+json { [ { \"tpid\" : \"<tpid>\" , \"type\" : \"IDCONSENT\" , \"status\" : \"VALID\" , \"changed_at\" : \"<timestamp>\" } , { \"tpid\" : \"<tpid>\" , \"tc\" : \"<tc-string>\" , \"changed_at\" : \"<timestamp>\" } ] }","title":"Data export for partners"},{"location":"doc_devp/","text":"Creating a netID Service \u00b6 Prerequisites \u00b6 We assume that you have already registered a service provider account at netID. If not, register a netID developer account https://developer.netid.de/ here. Creating a Service \u00b6 To start, log in into the netID Developer Portal . Create a service for which you want to leverage the netID single sign-on. Select Services in the menu, click Add service and fill in the required details in the following screen. Read the detailed documentation if you need further information. A sample service could look like this, where the service domain (Dienst Domain) is the domain of your customer facing website. Also, links to data privacy information (URL Datenrichtlinien) and terms of usage (URL AGB / Benutzungsbedingungen) should be supplied: Note: for testing purposes, you can actually enter any domain and URL values into this form, as they are not technically relevant in order to get the netID integration in Auth0 running In the end, it should look similar to this: Creating a Client \u00b6 Create a Client for this service by clicking on Client hinzuf\u00fcgen (Add client). Detailed documation on how to do this is available in the netID Developer Portal. Sample configuration: Note: the values here should be adjusted to your needs, especially \"Callback URL\", which needs to point to your backend In the end, it should look similar to this: Once the client is created it will initially run in a sandboxed mode, which means it can only be used with whitelisted netID-Accounts (email addresses). In order to successfully run through the initial integration add a test user (email address) to the whitelist by selecting Add Test-Account , outlined on the developer portal. Up to 10 accounts can be whitelisted per sandboxed client. Finally, find the Client ID and netID Token - Sandbox (later referred to as client secret ) by expanding the client details. USW \u00b6","title":"Developer Portal"},{"location":"doc_devp/#creating-a-netid-service","text":"","title":"Creating a netID Service"},{"location":"doc_devp/#prerequisites","text":"We assume that you have already registered a service provider account at netID. If not, register a netID developer account https://developer.netid.de/ here.","title":"Prerequisites"},{"location":"doc_devp/#creating-a-service","text":"To start, log in into the netID Developer Portal . Create a service for which you want to leverage the netID single sign-on. Select Services in the menu, click Add service and fill in the required details in the following screen. Read the detailed documentation if you need further information. A sample service could look like this, where the service domain (Dienst Domain) is the domain of your customer facing website. Also, links to data privacy information (URL Datenrichtlinien) and terms of usage (URL AGB / Benutzungsbedingungen) should be supplied: Note: for testing purposes, you can actually enter any domain and URL values into this form, as they are not technically relevant in order to get the netID integration in Auth0 running In the end, it should look similar to this:","title":"Creating a Service"},{"location":"doc_devp/#creating-a-client","text":"Create a Client for this service by clicking on Client hinzuf\u00fcgen (Add client). Detailed documation on how to do this is available in the netID Developer Portal. Sample configuration: Note: the values here should be adjusted to your needs, especially \"Callback URL\", which needs to point to your backend In the end, it should look similar to this: Once the client is created it will initially run in a sandboxed mode, which means it can only be used with whitelisted netID-Accounts (email addresses). In order to successfully run through the initial integration add a test user (email address) to the whitelist by selecting Add Test-Account , outlined on the developer portal. Up to 10 accounts can be whitelisted per sandboxed client. Finally, find the Client ID and netID Token - Sandbox (later referred to as client secret ) by expanding the client details.","title":"Creating a Client"},{"location":"doc_devp/#usw","text":"","title":"USW"},{"location":"doc_sso_developer/","text":"Single Sign-On Documentation \u00b6 This documentation describes the netID Single Sign-On to support the integration with interested relying parties. In order to aquire the necessary credentials to leverage this service please refer to the Developer Portal Documentation Integration Guide \u00b6 General Overview \u00b6 The protocol standard applied is OpenID Connect as per the OpenID Connect Core 1.0 specification using the Authorization Code Flow. Partners manage their data and clients in the netID Developer Portal. There, partners are able to manage their services, which may constitute groups of clients. These services receive the rights granted to partners by end users, which all clients in the group then have access to. All the clients' communication takes place via EnID's central SSO broker. The SSO broker distributes requests among the participating account providers, end users always authenticate to the account provider responsible for them, which is also where they authorize the release of their data for partners' services. Where necessary, clients request that data be released netID users; if the user agrees, the client receives an id_token and a userinfo object as a JSON structure. What the id_token and userinfo objects contain in particular is the end user's subject identifier (sub), which constitutes an ID for both the end user with regard to the service he or she is using as well as the actual client's redirect URI (redirect_uri). This sub value allows the end user to be recognized on the client. Claims und Scopes \u00b6 Every time netID is used to initiate an SSO process, details regarding which information is expected from the end user in the context of the request have to be provided. For that purpose, the OpenID Connect/OAuth2 scope and claim mechanisms serve as definitions. Every OpenID Connect request must always request the openid scope. Moreover, the master data required are to be expressed as essential claims. Once released by the end user, master data need not be provided again unless revoked by the user. The user's approval is saved. The following claims are supported by netID: gender - the end user's gender given_name - the end user's first name (or names) family_name - the end user's last name birthdate - the end user's date of birth email - the end user's email address email_verified - the verification status of the end user's email address address - physical mailing address, containing informations on postal code (ZIP), city or town, steet address and country where the end user's address is located The availability of these claims may, however, vary depending on the end user's account provider; in such cases where not all requested claims are provided, the client must find a way around this. Claims and scopes that are not requested as essential are ignored. Examples \u00b6 authorize \u00b6 authorize requests initiate SSO processes, the clients identify themselves with their client_id and redirect_uri and specify which claims and scopes are to be requested. Some optional parameters are also supported. Here, the endpoint https://broker.netid.de/authorize is used with the SSO broker. Examples, given both easy readable as well as in valid URL encoding. The encoding needs to be used for the redirect_uri as well: Minimum Query - SSO without requesting any additional data https://broker.netid.de/authorize? response_type = code & client_id =[ clientID ] & redirect_uri =[ redirect_uri ] & scope = openid Query for \u201cprofile\u201d scope as essential claim https://broker.netid.de/authorize? response_type = code & client_id =[ clientID ] & redirect_uri =[ redirect_uri ] & scope = openid & claims ={ \"userinfo\" : { \"birthdate\" : { \"essential\" :true } , \"gender\" : { \"essential\" :true } , \"given_name\" : { \"essential\" :true } , \"family_name\" : { \"essential\" :true } } } Query for claims that correspond to the \u201cprofile\u201d scope and \u201caddress\u201d as essential https://broker.netid.de/authorize? response_type = code & client_id =[ clientID ] & redirect_uri =[ redirect_uri ] & scope = openid & claims ={ \"userinfo\" : { \"birthdate\" : { \"essential\" :true } , \"address\" : { \"essential\" :true } , \"gender\" : { \"essential\" :true } , \"given_name\" : { \"essential\" :true } , \"family_name\" : { \"essential\" :true } } } token \u00b6 Token requests are carried out after the callback to the client in order to exchange the code provided for an access token. It is absolutely necessary that the code used remains unmodified. Here, the endpoint https://broker.netid.de/token is used with the SSO broker. Client Credentials are required for basic authentication. Example request per curl: curl -v -u [user:pass] -X POST https://broker.netid.de/token -H 'content-type: application/x-www-form-urlencoded; charset=UTF-8' -d 'code=[code]&redirect_uri=[redirect_uri]&grant_type=authorization_code' userinfo \u00b6 The access token is used to retrieve userinfo and id_token. Here, the endpoint https://broker.netid.de/userinfo is used with the SSO broker. Timing and Error Messages \u00b6 If the authorize request fails, the redirect_uri in the callback is given the reason why this occurred. With token requests, it's particularly important to ensure that the code provided is identical bit-by-bit to the one received in the callback to the redirect_uri, and to be able to assume that basic authentication is being used properly here. Each code is only valid for 30 seconds! Access tokens for the userinfo request are valid for 15 minutes and may also be used multiple times within this timeframe. Implementation Details \u00b6 The following request parameters are supported for initiating the SSO process: prompt login for requiring reauthentication with the account provider consent for requiring consent to be given again max_age in cases where time of authentication may not be too far in the past login_hint to provide and email address in order to prevent the broker's user interface from being visible to the user and thus directly redirect to the relevant account provider state The value of this parameter is passed through the entire flow transparently and included when calling back to the redirect_uri. It may be used to recognize how authorize request and asynchronous response are associated in the client. The sequence of the calls is summarized as follows: Detailed description of diagram: The end user initiates a process on the client's site that involves the use of netID. At this point, the client generates a netID button for an authorize request and redirects the end user to the SSO broker. The SSO broker validates the client's authorize request. The SSO broker generates a new authorize request and redirects the user to the OpenID provider. For their part, the broker appears to the OpenID provider as a relying party client. The OpenID provider validates the SSO broker's authorize request and displays the login screen to the end user; the user logs in with the account provider. The OpenID provider shows an approval page to the end user on which all the data he or she is asked to allow transfer of is displayed. The end user agrees to provide the requested data. The OpenID provider generates an AuthN Response and redirects to the SSO broker. The SSO broker receives the AuthN Response from the OpenID provider. The SSO broker generates a new AuthN Response and redirects to the client's redirect_uri. The client receives the SSO broker's AuthN Response. The actual data query is initiated. The client requests the access token with the SSO broker using the Auth Code (from the AuthN Response) and the Client Credentials. The SSO broker requests the access token from the OP using the Auth Code (from the AuthN Response) and the Client Credentials taken from the client. The OpenID provider issues an access token, giving it to the SSO broker. The SSO broker uses the access token to generate a new access token, giving this one to the client. The client uses the access token with the SSO broker to request the userinfo object. The SSO broker uses the access token to request the userinfo object from the OpenID provider. The OpenID provider grants the userinfo object to the SSO broker. The SSO broker grants the userinfo object to the client. The client has now received the userinfo object. Styling \u00b6 The depiction of the netID button is explained in the brand book. Best Practices \u00b6 It is largely up to the relying parties to decide where netID is to be incorporated in clients. Typical cases involve the use of netID as a login or data enrichment mechanism. As a login mechanism, for example, netID may be used like other SSO mechanisms (as well as alongside them) as an authentication alternative, or even used as the sole login method. Whether or not a local account is to be held in addition to the netID account is entirely up to the relying party. netID does not provide a classic session, but the SSO process is available via the authorize process at all times. An email address provided to the broker via a browser will be stored as a 1 st -party cookie; the end user may decide whether to remain logged in with the account provider. The end user's approval for the transfer of master data will be sought only upon the first request for such data, unless the user revokes his or her approval; ideally, this allows SSO flows to be able to run even with interaction from the user. If a relying party would like to also be able to handle authentication of end users independently of netID, it is advisable to ensure that mechanisms for merging or separating accounts are provided for. If local account representations with local credentials exist alongside netID, there should also be support processes for handling them; netID support processes only come into effect in connection with netID accounts themselves. In terms of data enrichment, examples may include using netID during registration processes to make it easier for users to enter information, or as a source for addresses when customers are checking out with their shopping carts online. Whether the data provided is to be used only temporarily or whether it should persist is again left up to the relying parties to freely decide. Each time netID is triggered, the data obtained is up to date in relation to the information currently available to the account provider. With regard to local copies, it may be reasonable to repeatedly request updates and synchronize them. The relying party is to take the principles of data protection into account as they pertain to local data retention. Ideally, data enrichment processes should be initiated in those places where the data is actually needed. This helps to optimize conversion rates while achieving a high degree of data minimization. One thing to be aware of is the verification status of email addresses: if an email address has already been verified with netID, a new request from the relying party to verify the email address is, generally speaking, unnecessary and may cause confusion on the part of the end user. Those netID accounts associated with account providers that are, for their part, email providers, are verified from the outset. If such an email account is deleted, not only does the end user lose the ability to use netID, but all support processes based on that email address will come to nothing. Security Information \u00b6 All communication with netID must be secured by TLS. This also applies to all URLs entered in the developer portal. netID exclusively supports the Authorization Code Flow, so that id_token is only transferred in TLS-secured back-end to back-end communication. Currently, the only token signature supported is none. Use of SDKs \u00b6 There are a large number of OpenID Connect client libraries available in many different language environments. Below, several examples will be given, along with tips for using them. Many client libraries are listed at https://openid.net/developers/libraries/ , and others are easy to find. General \u00b6 Regardless of the choice of environment, it's possible to do the following preliminary experiments: In the developer portal for the partner, create a service, request approval for it, and then create a client for it When choosing which URLs to use, it's possible to generate locally applicable test environments by making an entry in the hosts file of a developer workstation at the endpoints given for service and client and creating and using self-signed certificates. Example \"Entry in hosts\" 127.0.0.1 www.democlient.de Example \"Creating a self-signed certificate\" openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout key.pem -out cert.pem Here, for the Common Name give the host name of the environment you want; so, in this case: www.democlient.de . Using the Client Credentials from the developer portal, the local host entry, and the certificate with the key, it's possible to run through the netID requests. When testing with browsers, it's a good idea to use private windows; otherwise cookies left behind from previous run-throughs may cause confusion. to top Examples \u00b6 PHP In PHP it's possible to use the package https://github.com/jumbojett/OpenID-Connect-PHP.However , some adjustments are necessary, since netID always uses none for the token signature algorithm in the Authorization Code Flow. Installation according to instructions is no problem. The package derives the redirect_uri from its own URL; here, the position of the script in the path of the web server can either be used as redirect_uri when creating the client or configured accordingly in the web server using rewrite rules. The following minimal diff makes OpenIDConnectClient.php netID-compatible: 844a845,848 > $signature = base64url_decode(array_pop($parts)); > if (false === $signature || '' === $signature) { > throw new OpenIDConnectClientException('Error decoding signature from token'); > } 874,877d877 < // netID has 'none' < case 'none' : < $verified=true; < break; A simple sample client may then look like this: client_example.php Javascript One highly recommended JavaScript implementation (node.js) of an OpenID Connect relying party can be found here: https://www.npmjs.com/package/openid-client Java Spring Security examples for Java: GitHub:mitreid-connect/simple-web-app GitHub:eugenp/tutorials/tree/master/spring-security-openid Rust A good OpenID Connect relying party client for Rust can be found here: https://docs.rs/crate/oidc/0.2.0 . Go For go the package GitHub:coreos/go-oidc makes a netID login possible. The package may be installed here: go get github.com/coreos/go-oidc There is no explicit support for entering claims, essential or otherwise. The simple example client netid.go first needs to be edited before Client Credentials, host name, and certificates may be entered, after which it can be run using: go run netid.go","title":"SSO Integration"},{"location":"doc_sso_developer/#single-sign-on-documentation","text":"This documentation describes the netID Single Sign-On to support the integration with interested relying parties. In order to aquire the necessary credentials to leverage this service please refer to the Developer Portal Documentation","title":"Single Sign-On Documentation"},{"location":"doc_sso_developer/#integration-guide","text":"","title":"Integration Guide"},{"location":"doc_sso_developer/#general-overview","text":"The protocol standard applied is OpenID Connect as per the OpenID Connect Core 1.0 specification using the Authorization Code Flow. Partners manage their data and clients in the netID Developer Portal. There, partners are able to manage their services, which may constitute groups of clients. These services receive the rights granted to partners by end users, which all clients in the group then have access to. All the clients' communication takes place via EnID's central SSO broker. The SSO broker distributes requests among the participating account providers, end users always authenticate to the account provider responsible for them, which is also where they authorize the release of their data for partners' services. Where necessary, clients request that data be released netID users; if the user agrees, the client receives an id_token and a userinfo object as a JSON structure. What the id_token and userinfo objects contain in particular is the end user's subject identifier (sub), which constitutes an ID for both the end user with regard to the service he or she is using as well as the actual client's redirect URI (redirect_uri). This sub value allows the end user to be recognized on the client.","title":"General Overview"},{"location":"doc_sso_developer/#claims-und-scopes","text":"Every time netID is used to initiate an SSO process, details regarding which information is expected from the end user in the context of the request have to be provided. For that purpose, the OpenID Connect/OAuth2 scope and claim mechanisms serve as definitions. Every OpenID Connect request must always request the openid scope. Moreover, the master data required are to be expressed as essential claims. Once released by the end user, master data need not be provided again unless revoked by the user. The user's approval is saved. The following claims are supported by netID: gender - the end user's gender given_name - the end user's first name (or names) family_name - the end user's last name birthdate - the end user's date of birth email - the end user's email address email_verified - the verification status of the end user's email address address - physical mailing address, containing informations on postal code (ZIP), city or town, steet address and country where the end user's address is located The availability of these claims may, however, vary depending on the end user's account provider; in such cases where not all requested claims are provided, the client must find a way around this. Claims and scopes that are not requested as essential are ignored.","title":"Claims und Scopes"},{"location":"doc_sso_developer/#examples","text":"","title":"Examples"},{"location":"doc_sso_developer/#authorize","text":"authorize requests initiate SSO processes, the clients identify themselves with their client_id and redirect_uri and specify which claims and scopes are to be requested. Some optional parameters are also supported. Here, the endpoint https://broker.netid.de/authorize is used with the SSO broker. Examples, given both easy readable as well as in valid URL encoding. The encoding needs to be used for the redirect_uri as well: Minimum Query - SSO without requesting any additional data https://broker.netid.de/authorize? response_type = code & client_id =[ clientID ] & redirect_uri =[ redirect_uri ] & scope = openid Query for \u201cprofile\u201d scope as essential claim https://broker.netid.de/authorize? response_type = code & client_id =[ clientID ] & redirect_uri =[ redirect_uri ] & scope = openid & claims ={ \"userinfo\" : { \"birthdate\" : { \"essential\" :true } , \"gender\" : { \"essential\" :true } , \"given_name\" : { \"essential\" :true } , \"family_name\" : { \"essential\" :true } } } Query for claims that correspond to the \u201cprofile\u201d scope and \u201caddress\u201d as essential https://broker.netid.de/authorize? response_type = code & client_id =[ clientID ] & redirect_uri =[ redirect_uri ] & scope = openid & claims ={ \"userinfo\" : { \"birthdate\" : { \"essential\" :true } , \"address\" : { \"essential\" :true } , \"gender\" : { \"essential\" :true } , \"given_name\" : { \"essential\" :true } , \"family_name\" : { \"essential\" :true } } }","title":"authorize"},{"location":"doc_sso_developer/#token","text":"Token requests are carried out after the callback to the client in order to exchange the code provided for an access token. It is absolutely necessary that the code used remains unmodified. Here, the endpoint https://broker.netid.de/token is used with the SSO broker. Client Credentials are required for basic authentication. Example request per curl: curl -v -u [user:pass] -X POST https://broker.netid.de/token -H 'content-type: application/x-www-form-urlencoded; charset=UTF-8' -d 'code=[code]&redirect_uri=[redirect_uri]&grant_type=authorization_code'","title":"token"},{"location":"doc_sso_developer/#userinfo","text":"The access token is used to retrieve userinfo and id_token. Here, the endpoint https://broker.netid.de/userinfo is used with the SSO broker.","title":"userinfo"},{"location":"doc_sso_developer/#timing-and-error-messages","text":"If the authorize request fails, the redirect_uri in the callback is given the reason why this occurred. With token requests, it's particularly important to ensure that the code provided is identical bit-by-bit to the one received in the callback to the redirect_uri, and to be able to assume that basic authentication is being used properly here. Each code is only valid for 30 seconds! Access tokens for the userinfo request are valid for 15 minutes and may also be used multiple times within this timeframe.","title":"Timing and Error Messages"},{"location":"doc_sso_developer/#implementation-details","text":"The following request parameters are supported for initiating the SSO process: prompt login for requiring reauthentication with the account provider consent for requiring consent to be given again max_age in cases where time of authentication may not be too far in the past login_hint to provide and email address in order to prevent the broker's user interface from being visible to the user and thus directly redirect to the relevant account provider state The value of this parameter is passed through the entire flow transparently and included when calling back to the redirect_uri. It may be used to recognize how authorize request and asynchronous response are associated in the client. The sequence of the calls is summarized as follows: Detailed description of diagram: The end user initiates a process on the client's site that involves the use of netID. At this point, the client generates a netID button for an authorize request and redirects the end user to the SSO broker. The SSO broker validates the client's authorize request. The SSO broker generates a new authorize request and redirects the user to the OpenID provider. For their part, the broker appears to the OpenID provider as a relying party client. The OpenID provider validates the SSO broker's authorize request and displays the login screen to the end user; the user logs in with the account provider. The OpenID provider shows an approval page to the end user on which all the data he or she is asked to allow transfer of is displayed. The end user agrees to provide the requested data. The OpenID provider generates an AuthN Response and redirects to the SSO broker. The SSO broker receives the AuthN Response from the OpenID provider. The SSO broker generates a new AuthN Response and redirects to the client's redirect_uri. The client receives the SSO broker's AuthN Response. The actual data query is initiated. The client requests the access token with the SSO broker using the Auth Code (from the AuthN Response) and the Client Credentials. The SSO broker requests the access token from the OP using the Auth Code (from the AuthN Response) and the Client Credentials taken from the client. The OpenID provider issues an access token, giving it to the SSO broker. The SSO broker uses the access token to generate a new access token, giving this one to the client. The client uses the access token with the SSO broker to request the userinfo object. The SSO broker uses the access token to request the userinfo object from the OpenID provider. The OpenID provider grants the userinfo object to the SSO broker. The SSO broker grants the userinfo object to the client. The client has now received the userinfo object.","title":"Implementation Details"},{"location":"doc_sso_developer/#styling","text":"The depiction of the netID button is explained in the brand book.","title":"Styling"},{"location":"doc_sso_developer/#best-practices","text":"It is largely up to the relying parties to decide where netID is to be incorporated in clients. Typical cases involve the use of netID as a login or data enrichment mechanism. As a login mechanism, for example, netID may be used like other SSO mechanisms (as well as alongside them) as an authentication alternative, or even used as the sole login method. Whether or not a local account is to be held in addition to the netID account is entirely up to the relying party. netID does not provide a classic session, but the SSO process is available via the authorize process at all times. An email address provided to the broker via a browser will be stored as a 1 st -party cookie; the end user may decide whether to remain logged in with the account provider. The end user's approval for the transfer of master data will be sought only upon the first request for such data, unless the user revokes his or her approval; ideally, this allows SSO flows to be able to run even with interaction from the user. If a relying party would like to also be able to handle authentication of end users independently of netID, it is advisable to ensure that mechanisms for merging or separating accounts are provided for. If local account representations with local credentials exist alongside netID, there should also be support processes for handling them; netID support processes only come into effect in connection with netID accounts themselves. In terms of data enrichment, examples may include using netID during registration processes to make it easier for users to enter information, or as a source for addresses when customers are checking out with their shopping carts online. Whether the data provided is to be used only temporarily or whether it should persist is again left up to the relying parties to freely decide. Each time netID is triggered, the data obtained is up to date in relation to the information currently available to the account provider. With regard to local copies, it may be reasonable to repeatedly request updates and synchronize them. The relying party is to take the principles of data protection into account as they pertain to local data retention. Ideally, data enrichment processes should be initiated in those places where the data is actually needed. This helps to optimize conversion rates while achieving a high degree of data minimization. One thing to be aware of is the verification status of email addresses: if an email address has already been verified with netID, a new request from the relying party to verify the email address is, generally speaking, unnecessary and may cause confusion on the part of the end user. Those netID accounts associated with account providers that are, for their part, email providers, are verified from the outset. If such an email account is deleted, not only does the end user lose the ability to use netID, but all support processes based on that email address will come to nothing.","title":"Best Practices"},{"location":"doc_sso_developer/#security-information","text":"All communication with netID must be secured by TLS. This also applies to all URLs entered in the developer portal. netID exclusively supports the Authorization Code Flow, so that id_token is only transferred in TLS-secured back-end to back-end communication. Currently, the only token signature supported is none.","title":"Security Information"},{"location":"doc_sso_developer/#use-of-sdks","text":"There are a large number of OpenID Connect client libraries available in many different language environments. Below, several examples will be given, along with tips for using them. Many client libraries are listed at https://openid.net/developers/libraries/ , and others are easy to find.","title":"Use of SDKs"},{"location":"doc_sso_developer/#general","text":"Regardless of the choice of environment, it's possible to do the following preliminary experiments: In the developer portal for the partner, create a service, request approval for it, and then create a client for it When choosing which URLs to use, it's possible to generate locally applicable test environments by making an entry in the hosts file of a developer workstation at the endpoints given for service and client and creating and using self-signed certificates. Example \"Entry in hosts\" 127.0.0.1 www.democlient.de Example \"Creating a self-signed certificate\" openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout key.pem -out cert.pem Here, for the Common Name give the host name of the environment you want; so, in this case: www.democlient.de . Using the Client Credentials from the developer portal, the local host entry, and the certificate with the key, it's possible to run through the netID requests. When testing with browsers, it's a good idea to use private windows; otherwise cookies left behind from previous run-throughs may cause confusion. to top","title":"General"},{"location":"doc_sso_developer/#examples_1","text":"PHP In PHP it's possible to use the package https://github.com/jumbojett/OpenID-Connect-PHP.However , some adjustments are necessary, since netID always uses none for the token signature algorithm in the Authorization Code Flow. Installation according to instructions is no problem. The package derives the redirect_uri from its own URL; here, the position of the script in the path of the web server can either be used as redirect_uri when creating the client or configured accordingly in the web server using rewrite rules. The following minimal diff makes OpenIDConnectClient.php netID-compatible: 844a845,848 > $signature = base64url_decode(array_pop($parts)); > if (false === $signature || '' === $signature) { > throw new OpenIDConnectClientException('Error decoding signature from token'); > } 874,877d877 < // netID has 'none' < case 'none' : < $verified=true; < break; A simple sample client may then look like this: client_example.php Javascript One highly recommended JavaScript implementation (node.js) of an OpenID Connect relying party can be found here: https://www.npmjs.com/package/openid-client Java Spring Security examples for Java: GitHub:mitreid-connect/simple-web-app GitHub:eugenp/tutorials/tree/master/spring-security-openid Rust A good OpenID Connect relying party client for Rust can be found here: https://docs.rs/crate/oidc/0.2.0 . Go For go the package GitHub:coreos/go-oidc makes a netID login possible. The package may be installed here: go get github.com/coreos/go-oidc There is no explicit support for entering claims, essential or otherwise. The simple example client netid.go first needs to be edited before Client Credentials, host name, and certificates may be entered, after which it can be run using: go run netid.go","title":"Examples"},{"location":"faq/","text":"Test \u00b6 Text goes here","title":"FAQ"},{"location":"faq/#test","text":"Text goes here","title":"Test"},{"location":"plugins/","text":"Dummy","title":"Plugins"}]}